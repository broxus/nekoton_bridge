// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../nekoton_wrapper/core/keystore/models.dart';
import '../nekoton_wrapper/crypto/models.dart';
import '../utils/caller.dart';
import '../utils/logger.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'merged.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_connection`, `get_connection`, `get_connection`, `get_connection`, `get_storage`, `map_keystore_builder`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `GenericContractSubscriptionHandlerImpl`, `GqlConnectionImpl`, `JettonWalletSubscriptionHandlerImpl`, `JrpcConnectionImpl`, `ProtoConnectionImpl`, `ProviderMessage`, `ProviderTransaction`, `TokenWalletSubscriptionHandlerImpl`, `TonWalletSubscriptionHandlerImpl`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `get_public_key`, `get`, `is_local`, `on_balance_changed`, `on_balance_changed`, `on_custodians_changed`, `on_details_changed`, `on_message_expired`, `on_message_expired`, `on_message_sent`, `on_message_sent`, `on_state_changed`, `on_state_changed`, `on_transactions_found`, `on_transactions_found`, `on_transactions_found`, `on_transactions_found`, `on_unconfirmed_transactions_changed`, `post`, `post`, `post`, `remove_unchecked`, `remove`, `set_unchecked`, `set`, `sign_transaction`, `sign`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `my_format`

///----------------------------
/// CONTENT OF src/nekoton_wrapper/crypto/crypto_api.rs
///----------------------------
/// Check signature by publicKey and data
Future<bool> ntVerifySignature(
        {required String publicKey,
        required String data,
        required String signature,
        int? signatureId}) =>
    NekotonBridge.instance.api.crateApiMergedNtVerifySignature(
        publicKey: publicKey,
        data: data,
        signature: signature,
        signatureId: signatureId);

///----------------------------
/// CONTENT OF src/nekoton_wrapper/crypto/mnemonic/mnemonic_api.rs
///----------------------------
/// Generate seed phrase by specified mnemonic type
GeneratedKeyG ntGenerateKey({required MnemonicType accountType}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtGenerateKey(accountType: accountType);

/// Get hints for input part of word of seed phrase to get possible words
/// input: acco
/// returns [account, accommodate, ...]
List<String> ntGetHints({required String input}) =>
    NekotonBridge.instance.api.crateApiMergedNtGetHints(input: input);

/// Generate public and secret keys from seed phrase and mnemonic type
/// Returns json {'public': '...', 'secret': '...'}
/// or throws Exception
String ntDeriveFromPhrase(
        {required String phrase, required MnemonicType mnemonicType}) =>
    NekotonBridge.instance.api.crateApiMergedNtDeriveFromPhrase(
        phrase: phrase, mnemonicType: mnemonicType);

///----------------------------
/// CONTENT OF src/nekoton_wrapper/helpers/abi_api.rs
///----------------------------
/// Check if public key is correct.
/// If no - throws error, if ok - return true
Future<bool> ntCheckPublicKey({required String publicKey}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtCheckPublicKey(publicKey: publicKey);

/// Run contract local.
/// Return json-encoded ExecutionOutput or throws error.
///
/// input - is json-encoded AbiToken
Future<String> ntRunLocal(
        {required String accountStuffBoc,
        required String contractAbi,
        required String method,
        required String input,
        required bool responsible}) =>
    NekotonBridge.instance.api.crateApiMergedNtRunLocal(
        accountStuffBoc: accountStuffBoc,
        contractAbi: contractAbi,
        method: method,
        input: input,
        responsible: responsible);

/// Get address of tvc and contract_abi.
/// Returns list of [address, boc of state_init, hash] or throws error
Future<List<String>> ntGetExpectedAddress(
        {required String tvc,
        required String contractAbi,
        required int workchainId,
        String? publicKey,
        required String initData}) =>
    NekotonBridge.instance.api.crateApiMergedNtGetExpectedAddress(
        tvc: tvc,
        contractAbi: contractAbi,
        workchainId: workchainId,
        publicKey: publicKey,
        initData: initData);

/// Returns base64-encoded body that was encoded or throws error
Future<String> ntEncodeInternalInput(
        {required String contractAbi,
        required String method,
        required String input}) =>
    NekotonBridge.instance.api.crateApiMergedNtEncodeInternalInput(
        contractAbi: contractAbi, method: method, input: input);

/// Returns json-encoded SignedMessage from nekoton or throws error
/// timeout - milliseconds
Future<String> ntCreateExternalMessageWithoutSignature(
        {required String dst,
        required String contractAbi,
        required String method,
        String? stateInit,
        required String input,
        required int timeout}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtCreateExternalMessageWithoutSignature(
            dst: dst,
            contractAbi: contractAbi,
            method: method,
            stateInit: stateInit,
            input: input,
            timeout: timeout);

/// Create external unsigned message that can be listened and handled or throws error
/// timeout - milliseconds
Future<UnsignedMessageImpl> ntCreateExternalMessage(
        {required String dst,
        required String contractAbi,
        required String method,
        String? stateInit,
        required String input,
        required String publicKey,
        required int timeout}) =>
    NekotonBridge.instance.api.crateApiMergedNtCreateExternalMessage(
        dst: dst,
        contractAbi: contractAbi,
        method: method,
        stateInit: stateInit,
        input: input,
        publicKey: publicKey,
        timeout: timeout);

/// Parse payload and return optional json-encoded KnownPayload or throws error
Future<String> ntParseKnownPayload({required String payload}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtParseKnownPayload(payload: payload);

/// Decode input data and return json-encoded DecodedInput or throws error
Future<String> ntDecodeInput(
        {required String messageBody,
        required String contractAbi,
        String? method,
        required bool internal}) =>
    NekotonBridge.instance.api.crateApiMergedNtDecodeInput(
        messageBody: messageBody,
        contractAbi: contractAbi,
        method: method,
        internal: internal);

/// Decode input data and return json-encoded DecodedEvent or throws error
Future<String> ntDecodeEvent(
        {required String messageBody,
        required String contractAbi,
        String? event}) =>
    NekotonBridge.instance.api.crateApiMergedNtDecodeEvent(
        messageBody: messageBody, contractAbi: contractAbi, event: event);

/// Decode output data and return json-encoded DecodedOutput or throws error
Future<String> ntDecodeOutput(
        {required String messageBody,
        required String contractAbi,
        String? method}) =>
    NekotonBridge.instance.api.crateApiMergedNtDecodeOutput(
        messageBody: messageBody, contractAbi: contractAbi, method: method);

/// Decode transaction and return json-encoded DecodedTransaction or throws error
Future<String> ntDecodeTransaction(
        {required String transaction,
        required String contractAbi,
        String? method}) =>
    NekotonBridge.instance.api.crateApiMergedNtDecodeTransaction(
        transaction: transaction, contractAbi: contractAbi, method: method);

/// Decode events of transaction and return json-encoded list of DecodedEvent or throws error
Future<String> ntDecodeTransactionEvents(
        {required String transaction, required String contractAbi}) =>
    NekotonBridge.instance.api.crateApiMergedNtDecodeTransactionEvents(
        transaction: transaction, contractAbi: contractAbi);

/// Returns hash of decoded boc or throws error
Future<String> ntGetBocHash({required String boc}) =>
    NekotonBridge.instance.api.crateApiMergedNtGetBocHash(boc: boc);

/// Return base64 encoded bytes of tokens or throws error
/// returns [tvc, hash]
Future<List<String>> ntPackIntoCell(
        {required String params, required String tokens, String? version}) =>
    NekotonBridge.instance.api.crateApiMergedNtPackIntoCell(
        params: params, tokens: tokens, version: version);

/// Parse list of params and return json-encoded Tokens or throws error
Future<String> ntUnpackFromCell(
        {required String params,
        required String boc,
        required bool allowPartial,
        String? version}) =>
    NekotonBridge.instance.api.crateApiMergedNtUnpackFromCell(
        params: params, boc: boc, allowPartial: allowPartial, version: version);

/// Pack address std smd or throw error
/// Returns new packed address as string
Future<String> ntPackStdSmcAddr(
        {required String addr,
        required bool base64Url,
        required bool bounceable}) =>
    NekotonBridge.instance.api.crateApiMergedNtPackStdSmcAddr(
        addr: addr, base64Url: base64Url, bounceable: bounceable);

/// Unpack address std smd or throw error.
/// Returns json-encoded MsgAddressInt
Future<String> ntUnpackStdSmcAddr(
        {required String packed, required bool base64Url}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtUnpackStdSmcAddr(packed: packed, base64Url: base64Url);

/// Return true if address is valid, false otherwise
bool ntValidateAddress({required String address}) => NekotonBridge.instance.api
    .crateApiMergedNtValidateAddress(address: address);

/// Repack address and return MsgAddressInt string or original string if failed
String ntRepackAddress({required String address}) =>
    NekotonBridge.instance.api.crateApiMergedNtRepackAddress(address: address);

String ntPackAddress(
        {required String address,
        required bool isUrlSafe,
        required bool bounceable}) =>
    NekotonBridge.instance.api.crateApiMergedNtPackAddress(
        address: address, isUrlSafe: isUrlSafe, bounceable: bounceable);

/// Extract public key from boc and return it or throw error
Future<String> ntExtractPublicKey({required String boc}) =>
    NekotonBridge.instance.api.crateApiMergedNtExtractPublicKey(boc: boc);

/// Convert code to base64 tvc string and return it or throw error
/// returns [tvc, hash]
Future<List<String>> ntCodeToTvc({required String code}) =>
    NekotonBridge.instance.api.crateApiMergedNtCodeToTvc(code: code);

/// Merge code and data to tvc base64 string and return it or throw error
/// returns [tvc, hash]
Future<List<String>> ntMergeTvc({required String code, required String data}) =>
    NekotonBridge.instance.api.crateApiMergedNtMergeTvc(code: code, data: data);

/// Split base64 tvc string into data and code.
/// Return vec![data, code] or throw error
Future<List<String?>> ntSplitTvc({required String tvc}) =>
    NekotonBridge.instance.api.crateApiMergedNtSplitTvc(tvc: tvc);

/// Set salt to code and return base64-encoded string or throw error
/// returns [tvc, hash]
Future<List<String>> ntSetCodeSalt(
        {required String code, required String salt}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtSetCodeSalt(code: code, salt: salt);

/// Get salt from code if possible and return base64-encoded salt or throw error
Future<String?> ntGetCodeSalt({required String code}) =>
    NekotonBridge.instance.api.crateApiMergedNtGetCodeSalt(code: code);

/// Run contract locally.
/// [config] - base64-encoded ConfigParams after (getBlockchainConfig)
/// [message] - base64-encoded Message after (encodeInternalMessage)
/// [utime] - unixtime in milliseconds
/// [account] - account address
/// Returns [boc, transaction] if everything is ok or
/// [error_code] if transaction failed
/// or throws error
Future<List<String>> ntExecuteLocal(
        {required String config,
        required String account,
        required String message,
        required int utime,
        required bool disableSignatureCheck,
        String? overwriteBalance,
        int? globalId}) =>
    NekotonBridge.instance.api.crateApiMergedNtExecuteLocal(
        config: config,
        account: account,
        message: message,
        utime: utime,
        disableSignatureCheck: disableSignatureCheck,
        overwriteBalance: overwriteBalance,
        globalId: globalId);

/// Unpack data by contract.
/// Returns [option publicKey, json-encoded Map<String, Token>] or throw error
Future<List<String?>> ntUnpackInitData(
        {required String contractAbi, required String data}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtUnpackInitData(contractAbi: contractAbi, data: data);

/// Unpack contract fields.
/// Returns optional json-encoded Map<String, Token> or throw error
Future<String?> ntUnpackContractFields(
        {required String contractAbi,
        required String boc,
        required bool allowPartial}) =>
    NekotonBridge.instance.api.crateApiMergedNtUnpackContractFields(
        contractAbi: contractAbi, boc: boc, allowPartial: allowPartial);

/// Returns json-encoded SignedMessage or throws error
/// dst - destination address
/// timeout - milliseconds
Future<String> ntCreateRawExternalMessage(
        {required String dst,
        String? stateInit,
        String? body,
        required int timeout}) =>
    NekotonBridge.instance.api.crateApiMergedNtCreateRawExternalMessage(
        dst: dst, stateInit: stateInit, body: body, timeout: timeout);

/// Returns base-64 encoded Message or throws error
/// src - address of sender
/// dst - address of destination
/// body - base64-encoded data
Future<String> ntEncodeInternalMessage(
        {String? src,
        required String dst,
        required bool bounce,
        String? stateInit,
        String? body,
        required String amount,
        bool? bounced}) =>
    NekotonBridge.instance.api.crateApiMergedNtEncodeInternalMessage(
        src: src,
        dst: dst,
        bounce: bounce,
        stateInit: stateInit,
        body: body,
        amount: amount,
        bounced: bounced);

/// Returns base-64 encoded Account or throws error
Future<String> ntMakeFullAccountBoc({String? accountStuffBoc}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtMakeFullAccountBoc(accountStuffBoc: accountStuffBoc);

/// Returns optional json-encoded FullContractState or throws error
/// account - base64-encoded boc after execute_local
Future<String?> ntParseFullAccountBoc({required String account}) =>
    NekotonBridge.instance.api
        .crateApiMergedNtParseFullAccountBoc(account: account);

Future<String> ntComputeStorageFee(
        {required String config,
        required String account,
        required int utime,
        required bool isMasterchain}) =>
    NekotonBridge.instance.api.crateApiMergedNtComputeStorageFee(
        config: config,
        account: account,
        utime: utime,
        isMasterchain: isMasterchain);

///----------------------------
/// CONTENT OF src/utils/tests_api.rs
///----------------------------
Future<void> testLoggerInfo({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedTestLoggerInfo(string: string);

Future<void> testLoggerDebug({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedTestLoggerDebug(string: string);

Future<void> testLoggerWarn({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedTestLoggerWarn(string: string);

Future<void> testLoggerError({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedTestLoggerError(string: string);

Future<void> testLoggerPanic({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedTestLoggerPanic(string: string);

Future<DynamicValue> testCallerCallTest0Async(
        {required String string, required bool needResult}) =>
    NekotonBridge.instance.api.crateApiMergedTestCallerCallTest0Async(
        string: string, needResult: needResult);

DynamicValue testCallerCallTest0Sync(
        {required String string, required bool needResult}) =>
    NekotonBridge.instance.api.crateApiMergedTestCallerCallTest0Sync(
        string: string, needResult: needResult);

Future<DynamicValue> testCallerCallTest1Async(
        {required String string, required bool needResult}) =>
    NekotonBridge.instance.api.crateApiMergedTestCallerCallTest1Async(
        string: string, needResult: needResult);

///----------------------------
/// CONTENT OF src/utils/api.rs
///----------------------------
/// Init utils
Future<void> initLogger(
        {required LogLevel level, required bool mobileLogger}) =>
    NekotonBridge.instance.api
        .crateApiMergedInitLogger(level: level, mobileLogger: mobileLogger);

/// Create log stream
Stream<LogEntry> createLogStream() =>
    NekotonBridge.instance.api.crateApiMergedCreateLogStream();

/// Init tokio runtime
Future<void> initRuntime() =>
    NekotonBridge.instance.api.crateApiMergedInitRuntime();

/// Init caller
Stream<DartCallStubRegistred> initCaller() =>
    NekotonBridge.instance.api.crateApiMergedInitCaller();

/// Callback functions for returning Dart method result
void callSendResult({required String id, required DynamicValue value}) =>
    NekotonBridge.instance.api
        .crateApiMergedCallSendResult(id: id, value: value);

/// Set clock offset in milliseconds
Future<void> setClockOffset({required PlatformInt64 offsetMs}) =>
    NekotonBridge.instance.api.crateApiMergedSetClockOffset(offsetMs: offsetMs);

Future<void> simpleLog({required String string}) =>
    NekotonBridge.instance.api.crateApiMergedSimpleLog(string: string);

Future<void> simplePanic() =>
    NekotonBridge.instance.api.crateApiMergedSimplePanic();

int simpleAdderSync({required int a, required int b}) =>
    NekotonBridge.instance.api.crateApiMergedSimpleAdderSync(a: a, b: b);

Future<int> simpleAdder({required int a, required int b}) =>
    NekotonBridge.instance.api.crateApiMergedSimpleAdder(a: a, b: b);

Future<DynamicValue> stubDv() =>
    NekotonBridge.instance.api.crateApiMergedStubDv();

Future<DartCallStub> stubDcs() =>
    NekotonBridge.instance.api.crateApiMergedStubDcs();

Future<void> simpleCallDart() =>
    NekotonBridge.instance.api.crateApiMergedSimpleCallDart();

Future<void> stubCallDart({required DartCallStub stub}) =>
    NekotonBridge.instance.api.crateApiMergedStubCallDart(stub: stub);

Future<void> simpleCallFunc0({required bool needResult}) =>
    NekotonBridge.instance.api
        .crateApiMergedSimpleCallFunc0(needResult: needResult);

Future<void> simpleCallFunc1({required bool needResult}) =>
    NekotonBridge.instance.api
        .crateApiMergedSimpleCallFunc1(needResult: needResult);

Future<void> simpleCallFunc2() =>
    NekotonBridge.instance.api.crateApiMergedSimpleCallFunc2();

Future<void> simpleCallFunc3() =>
    NekotonBridge.instance.api.crateApiMergedSimpleCallFunc3();

// Rust type: RustOpaqueNom<Arc < dyn AccountsStorageBoxTrait >>
abstract class ArcAccountsStorageBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn GenericContractBoxTrait >>
abstract class ArcGenericContractBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn GqlConnectionBoxTrait >>
abstract class ArcGqlConnectionBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn JettonWalletBoxTrait >>
abstract class ArcJettonWalletBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn JrpcConnectionBoxTrait >>
abstract class ArcJrpcConnectionBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn KeyStoreApiBoxTrait >>
abstract class ArcKeyStoreApiBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn LedgerConnectionBoxTrait >>
abstract class ArcLedgerConnectionBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn ProtoConnectionBoxTrait >>
abstract class ArcProtoConnectionBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn StorageBoxTrait >>
abstract class ArcStorageBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn TokenWalletBoxTrait >>
abstract class ArcTokenWalletBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn TonWalletBoxTrait >>
abstract class ArcTonWalletBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn TransportBoxTrait >>
abstract class ArcTransportBoxTrait implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<Arc < dyn UnsignedMessageBoxTrait >>
abstract class ArcUnsignedMessageBoxTrait implements RustOpaqueInterface {}

abstract class MyFormat {
  Future<String> myFormat();
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/accounts_storage/accounts_storage_api.rs
///----------------------------
/// Implementation of AccountsStorage
class AccountsStorageImpl {
  final ArcAccountsStorageBoxTrait innerStorage;

  const AccountsStorageImpl({
    required this.innerStorage,
  });

  /// Add new account to storage and return its instance.
  /// account - json-encoded AccountToAdd.
  /// Return json-encoded AssetsList or throw error.
  Future<String> addAccount({required String account}) =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplAddAccount(
          that: this, account: account);

  /// Add list of new accounts to storage and return it instances.
  /// account - json-encoded list of AccountToAdd.
  /// Return json-encoded list of AssetsList or throw error.
  Future<String> addAccounts({required String accounts}) =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplAddAccounts(
          that: this, accounts: accounts);

  /// Add token wallet signature to account (add new token to account aka enable it via slider).
  /// account_address - address of account
  /// network_group - name of network group where this token must be visible, could be found in
  ///   connection info
  /// root_token_contract - address of token in blockchain.
  /// Return updated AssetsList or throw error.
  Future<String> addTokenWallet(
          {required String accountAddress,
          required String networkGroup,
          required String rootTokenContract}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplAddTokenWallet(
              that: this,
              accountAddress: accountAddress,
              networkGroup: networkGroup,
              rootTokenContract: rootTokenContract);

  /// Add token wallets signatures to account (add new tokens to account aka enable it via slider).
  /// account_address - address of account
  /// network_group - name of network group where this token must be visible, could be found in
  ///   connection info
  /// root_token_contracts - list of addresses of tokens in blockchain.
  /// Return true or throw error.
  Future<bool> addTokenWallets(
          {required String accountAddress,
          required String networkGroup,
          required List<String> rootTokenContracts}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplAddTokenWallets(
              that: this,
              accountAddress: accountAddress,
              networkGroup: networkGroup,
              rootTokenContracts: rootTokenContracts);

  /// Clear storage and remove all data.
  /// Returns true or throw error
  Future<bool> clear() =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplClear(
        that: this,
      );

  /// Get list of accounts.
  /// Returns json-encoded List of AssetsList or throw error
  Future<String> getEntries() =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplGetEntries(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create AccountsStorage or throw error
  static Future<AccountsStorageImpl> newInstance(
          {required StorageDartWrapper storage}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplNew(storage: storage);

  /// Reload storage and read all data again.
  /// Returns true or throw error.
  Future<bool> reload() =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplReload(
        that: this,
      );

  /// Remove account from storage and return its instance if it was removed.
  /// account_address - address of account
  /// Return json-encoded AssetsList that was removed or null or throw error.
  Future<String?> removeAccount({required String accountAddress}) =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplRemoveAccount(
          that: this, accountAddress: accountAddress);

  /// Remove list of account from storage and return it instances if it were removed.
  /// account_addresses - list of addresses of accounts.
  /// Return json-encoded list of AssetsList that were removed or throw error.
  Future<String> removeAccounts({required List<String> accountAddresses}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplRemoveAccounts(
              that: this, accountAddresses: accountAddresses);

  /// Remove token wallet signature from account (remove token from account aka disable it via slider).
  /// account_address - address of account
  /// network_group - name of network group where this token must be visible, could be found in
  ///   connection info
  /// root_token_contract - address of token in blockchain.
  /// Return updated AssetsList or throw error.
  Future<String> removeTokenWallet(
          {required String accountAddress,
          required String networkGroup,
          required String rootTokenContract}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplRemoveTokenWallet(
              that: this,
              accountAddress: accountAddress,
              networkGroup: networkGroup,
              rootTokenContract: rootTokenContract);

  /// Remove token wallets signatures from account (remove tokens from account aka disable it via slider).
  /// account_address - address of account
  /// network_group - name of network group where this token must be visible, could be found in
  ///   connection info
  /// root_token_contracts - list of addresses of tokens in blockchain.
  /// Return true or throw error.
  Future<bool> removeTokenWallets(
          {required String accountAddress,
          required String networkGroup,
          required List<String> rootTokenContracts}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplRemoveTokenWallets(
              that: this,
              accountAddress: accountAddress,
              networkGroup: networkGroup,
              rootTokenContracts: rootTokenContracts);

  /// Rename existed account and return its renamed instance.
  /// account_address - address of account
  /// name - new name of account
  /// Return json-encoded AssetsList or throw error.
  Future<String> renameAccount(
          {required String accountAddress, required String name}) =>
      NekotonBridge.instance.api.crateApiMergedAccountsStorageImplRenameAccount(
          that: this, accountAddress: accountAddress, name: name);

  /// Check if data is correct for storage.
  static Future<bool> verifyData({required String data}) =>
      NekotonBridge.instance.api
          .crateApiMergedAccountsStorageImplVerifyData(data: data);

  @override
  int get hashCode => innerStorage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountsStorageImpl &&
          runtimeType == other.runtimeType &&
          innerStorage == other.innerStorage;
}

enum Bip39Entropy {
  bits128,
  bits256,
  ;
}

/// Mirror struct of Bip39MnemonicData
class Bip39MnemonicData {
  final int accountId;
  final Bip39Path path;
  final Bip39Entropy entropy;

  const Bip39MnemonicData({
    required this.accountId,
    required this.path,
    required this.entropy,
  });

  @override
  int get hashCode => accountId.hashCode ^ path.hashCode ^ entropy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip39MnemonicData &&
          runtimeType == other.runtimeType &&
          accountId == other.accountId &&
          path == other.path &&
          entropy == other.entropy;
}

enum Bip39Path {
  ever,
  ton,
  ;
}

class CallerTestClass {
  final String instanceHash;
  final int value;

  const CallerTestClass({
    required this.instanceHash,
    required this.value,
  });

  Future<void> callSomeFunc() =>
      NekotonBridge.instance.api.crateApiMergedCallerTestClassCallSomeFunc(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<CallerTestClass> newInstance(
          {required String instanceHash, required int value}) =>
      NekotonBridge.instance.api.crateApiMergedCallerTestClassNew(
          instanceHash: instanceHash, value: value);

  @override
  int get hashCode => instanceHash.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CallerTestClass &&
          runtimeType == other.runtimeType &&
          instanceHash == other.instanceHash &&
          value == other.value;
}

/// Wrapper struct above GeneratedKey with suitable type for generation
class GeneratedKeyG {
  final List<String> words;
  final MnemonicType accountType;

  const GeneratedKeyG({
    required this.words,
    required this.accountType,
  });

  @override
  int get hashCode => words.hashCode ^ accountType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeneratedKeyG &&
          runtimeType == other.runtimeType &&
          words == other.words &&
          accountType == other.accountType;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/generic_contract/generic_contract_api.rs
///----------------------------
class GenericContractDartWrapper {
  final ArcGenericContractBoxTrait innerContract;

  const GenericContractDartWrapper({
    required this.innerContract,
  });

  /// Get address of contract.
  Future<String> address() => NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperAddress(
        that: this,
      );

  /// Get json-encoded ContractState or throw error.
  Future<String> contractState() => NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperContractState(
        that: this,
      );

  /// Calculate fees for transaction.
  /// signed_message - json-encoded SignedMessage.
  /// Returns fees as string representation of u128 or throw error.
  Future<String> estimateFees({required String signedMessage}) =>
      NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperEstimateFees(
              that: this, signedMessage: signedMessage);

  /// Execute transaction locally and return its instance.
  /// signed_message - json-encoded SignedMessage
  /// options - additional info for execution
  /// Return json-encoded Transaction or throw error.
  Future<String> executeTransactionLocally(
          {required String signedMessage, required String options}) =>
      NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperExecuteTransactionLocally(
              that: this, signedMessage: signedMessage, options: options);

  /// Handle block of blockchain.
  /// block - base64-encoded Block.
  /// Return true or throw error.
  Future<bool> handleBlock({required String block}) =>
      NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperHandleBlock(
              that: this, block: block);

  /// Get list of json-encoded PendingTransaction or throw error.
  Future<String> pendingTransactions() => NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperPendingTransactions(
        that: this,
      );

  /// Get PollingMethod of contract or throw error.
  Future<PollingMethod> pollingMethod() => NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperPollingMethod(
        that: this,
      );

  /// Preload transactions of contract.
  /// from_lt - offset for loading data, string representation of u64
  /// Returns true or throw error.
  Future<bool> preloadTransactions({required String fromLt}) =>
      NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperPreloadTransactions(
              that: this, fromLt: fromLt);

  /// Refresh contract and update its data.
  /// Returns true or throw error.
  Future<bool> refresh() => NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperRefresh(
        that: this,
      );

  /// Send message to blockchain and receive transaction of send.
  /// signed_message - json-encoded SignedMessage.
  /// Returns json-encoded PendingTransaction or throw error.
  Future<String> send({required String signedMessage}) =>
      NekotonBridge.instance.api.crateApiMergedGenericContractDartWrapperSend(
          that: this, signedMessage: signedMessage);

  /// Create GenericContract by subscribing to its instance.
  /// address - address of contract
  /// preload_transactions - if transactions must be loaded during creation
  static Future<GenericContractDartWrapper> subscribe(
          {required String instanceHash,
          required String address,
          required bool preloadTransactions,
          required ArcTransportBoxTrait transport}) =>
      NekotonBridge.instance.api
          .crateApiMergedGenericContractDartWrapperSubscribe(
              instanceHash: instanceHash,
              address: address,
              preloadTransactions: preloadTransactions,
              transport: transport);

  @override
  int get hashCode => innerContract.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GenericContractDartWrapper &&
          runtimeType == other.runtimeType &&
          innerContract == other.innerContract;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/external/gql_connection_api.rs
///----------------------------
/// This is a wrapper structure above GqlConnectionBoxTrait to provide instance in dart side.
class GqlConnectionDartWrapper {
  final ArcGqlConnectionBoxTrait innerConnection;

  const GqlConnectionDartWrapper.raw({
    required this.innerConnection,
  });

  factory GqlConnectionDartWrapper(
          {required bool isLocal, required String instanceHash}) =>
      NekotonBridge.instance.api.crateApiMergedGqlConnectionDartWrapperNew(
          isLocal: isLocal, instanceHash: instanceHash);

  @override
  int get hashCode => innerConnection.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GqlConnectionDartWrapper &&
          runtimeType == other.runtimeType &&
          innerConnection == other.innerConnection;
}

/// Wrapper structure above GqlTransport that provides interface to communicate with it
/// via TransportBoxTrait.
class GqlTransportImpl {
  final ArcTransportBoxTrait innerTransport;

  const GqlTransportImpl.raw({
    required this.innerTransport,
  });

  /// Get list of accounts by code hash. Returns json-encoded AccountsList or throw error
  Future<String> getAccountsByCodeHash(
          {required String codeHash,
          required int limit,
          String? continuation}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplGetAccountsByCodeHash(
              that: this,
              codeHash: codeHash,
              limit: limit,
              continuation: continuation);

  /// Get transport block by id and return base64 encoded block or throw error
  Future<String> getBlock({required String id}) => NekotonBridge.instance.api
      .crateApiMergedGqlTransportImplGetBlock(that: this, id: id);

  /// Get config of transport.
  /// Returns json-encoded BlockchainConfigDef or throw error
  Future<String> getBlockchainConfig({required bool force}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplGetBlockchainConfig(
              that: this, force: force);

  /// Get contract state of address and return json-encoded RawContractState or throw error
  Future<String> getContractState({required String address}) =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetContractState(
          that: this, address: address);

  /// Call get_dst_transaction of nekoton's transport and
  /// return option json-encoded RawTransaction or throw error
  Future<String?> getDstTransaction({required String messageHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplGetDstTransaction(
              that: this, messageHash: messageHash);

  Future<String> getFeeFactors({required bool isMasterchain}) =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetFeeFactors(
          that: this, isMasterchain: isMasterchain);

  /// Get full contract state of address and return json-encoded FullContractState or throw error
  Future<String?> getFullContractState({required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplGetFullContractState(
              that: this, address: address);

  /// Get latest block by address and return it or throw error
  Future<LatestBlock> getLatestBlock({required String address}) =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetLatestBlock(
          that: this, address: address);

  /// Get id of network or throw error
  Future<int> getNetworkId() =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetNetworkId(
        that: this,
      );

  /// Get transport signature id and return it or throw error
  Future<int?> getSignatureId() =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetSignatureId(
        that: this,
      );

  /// Get single transaction by its hash.
  /// Return json-encoded Transaction or throw error
  Future<String?> getTransaction({required String hash}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplGetTransaction(that: this, hash: hash);

  /// Get list of transactions by address.
  /// Return json-encoded TransactionsList or throw error
  Future<String> getTransactions(
          {required String address, String? fromLt, required int count}) =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplGetTransactions(
          that: this, address: address, fromLt: fromLt, count: count);

  factory GqlTransportImpl({required GqlConnectionDartWrapper gqlConnection}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplNew(gqlConnection: gqlConnection);

  Future<String> simulateTransactionTree(
          {required String signedMessage,
          required List<int> ignoredComputePhaseCodes,
          required List<int> ignoredActionPhaseCodes}) =>
      NekotonBridge.instance.api
          .crateApiMergedGqlTransportImplSimulateTransactionTree(
              that: this,
              signedMessage: signedMessage,
              ignoredComputePhaseCodes: ignoredComputePhaseCodes,
              ignoredActionPhaseCodes: ignoredActionPhaseCodes);

  /// Wait until next block will come to blockchain and return its id or throw error
  /// timeout - in milliseconds
  Future<String> waitForNextBlock(
          {required String currentBlockId,
          required String address,
          required BigInt timeout}) =>
      NekotonBridge.instance.api.crateApiMergedGqlTransportImplWaitForNextBlock(
          that: this,
          currentBlockId: currentBlockId,
          address: address,
          timeout: timeout);

  @override
  int get hashCode => innerTransport.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GqlTransportImpl &&
          runtimeType == other.runtimeType &&
          innerTransport == other.innerTransport;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/jetton_wallet/jetton_wallet_api.rs
///----------------------------
class JettonWalletDartWrapper {
  final ArcJettonWalletBoxTrait innerWallet;

  const JettonWalletDartWrapper({
    required this.innerWallet,
  });

  /// Get address of wallet.
  Future<String> address() =>
      NekotonBridge.instance.api.crateApiMergedJettonWalletDartWrapperAddress(
        that: this,
      );

  /// Get balance of wallet.
  /// Return string representation of rust BigUInt
  Future<String> balance() =>
      NekotonBridge.instance.api.crateApiMergedJettonWalletDartWrapperBalance(
        that: this,
      );

  /// Get json-encoded ContractState or throw error.
  Future<String> contractState() => NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperContractState(
        that: this,
      );

  Future<String> estimateMinAttachedAmount({required String destination}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperEstimateMinAttachedAmount(
              that: this, destination: destination);

  /// Get details about root contract by address of JettonWallet
  /// Return json-encoded RootJettonContractDetails
  /// or throw error.
  static Future<String> getJettonRootDetails(
          {required ArcTransportBoxTrait transport,
          required String tokenRootAddress}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperGetJettonRootDetails(
              transport: transport, tokenRootAddress: tokenRootAddress);

  /// Get details about root contract by address of JettonWallet
  /// Return json-encoded list with 2 positions:
  /// 0: Address of root contract
  /// 1: RootJettonContractDetails of root contract
  /// or throw error.
  static Future<String> getJettonRootDetailsFromJettonWallet(
          {required ArcTransportBoxTrait transport,
          required String tokenWalletAddress}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperGetJettonRootDetailsFromJettonWallet(
              transport: transport, tokenWalletAddress: tokenWalletAddress);

  /// Get details about token wallet by address of wallet
  /// address - address of wallet
  /// Return json-encoded list with 2 positions:
  /// 0: JettonWalletDetails
  /// 1: RootJettonContractDetails
  /// or throw error
  static Future<String> getJettonWalletDetails(
          {required ArcTransportBoxTrait transport, required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperGetJettonWalletDetails(
              transport: transport, address: address);

  /// Handle block of blockchain.
  /// block - base64-encoded Block.
  /// Return true or throw error.
  Future<bool> handleBlock({required String block}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperHandleBlock(
              that: this, block: block);

  /// Get address of owner of wallet.
  Future<String> owner() =>
      NekotonBridge.instance.api.crateApiMergedJettonWalletDartWrapperOwner(
        that: this,
      );

  /// Preload transactions of wallet.
  /// from_lt - offset for loading data, string representation of u64
  /// Returns true or throw error.
  Future<bool> preloadTransactions({required String fromLt}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperPreloadTransactions(
              that: this, fromLt: fromLt);

  /// Prepare transferring tokens from this wallet to other.
  /// destination - address of account that should receive token
  /// amount - amount of tokens that should be transferred
  /// notify_receiver - if receiver should be notifier by blockchain
  /// payload - payload of transfer aka comment
  /// attached_amount - string representation of rust u64, default 400000000. How many native tokens
  ///   should be attached to transfer.
  /// Return json-encoded InternalMessage or throw error.
  Future<String> prepareTransfer(
          {required String amount,
          required String destination,
          required String remainingGasTo,
          String? customPayload,
          required String callbackValue,
          String? callbackPayload,
          String? attachedAmount}) =>
      NekotonBridge.instance.api
          .crateApiMergedJettonWalletDartWrapperPrepareTransfer(
              that: this,
              amount: amount,
              destination: destination,
              remainingGasTo: remainingGasTo,
              customPayload: customPayload,
              callbackValue: callbackValue,
              callbackPayload: callbackPayload,
              attachedAmount: attachedAmount);

  /// Refresh wallet and update its data.
  /// Returns true or throw error.
  Future<bool> refresh() =>
      NekotonBridge.instance.api.crateApiMergedJettonWalletDartWrapperRefresh(
        that: this,
      );

  /// Create JettonWallet by subscribing to its instance.
  /// owner - address of account that is owner of wallet
  /// root_token_contract - address of contract in blockchain
  static Future<JettonWalletDartWrapper> subscribe(
          {required String instanceHash,
          required String owner,
          required String rootTokenContract,
          required ArcTransportBoxTrait transport,
          required bool preloadTransactions}) =>
      NekotonBridge.instance.api.crateApiMergedJettonWalletDartWrapperSubscribe(
          instanceHash: instanceHash,
          owner: owner,
          rootTokenContract: rootTokenContract,
          transport: transport,
          preloadTransactions: preloadTransactions);

  @override
  int get hashCode => innerWallet.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JettonWalletDartWrapper &&
          runtimeType == other.runtimeType &&
          innerWallet == other.innerWallet;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/external/jrpc_connection_api.rs
///----------------------------
/// This is a wrapper structure above JrpcConnectionBoxTrait to provide instance in dart side.
class JrpcConnectionDartWrapper {
  final ArcJrpcConnectionBoxTrait innerConnection;

  const JrpcConnectionDartWrapper.raw({
    required this.innerConnection,
  });

  factory JrpcConnectionDartWrapper({required String instanceHash}) =>
      NekotonBridge.instance.api.crateApiMergedJrpcConnectionDartWrapperNew(
          instanceHash: instanceHash);

  @override
  int get hashCode => innerConnection.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JrpcConnectionDartWrapper &&
          runtimeType == other.runtimeType &&
          innerConnection == other.innerConnection;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/transport/jrpc_transport_api.rs
///----------------------------
/// Wrapper structure above JrpcTransport that provides interface to communicate with it
/// via TransportBoxTrait.
class JrpcTransportImpl {
  final ArcTransportBoxTrait innerTransport;

  const JrpcTransportImpl.raw({
    required this.innerTransport,
  });

  /// Get list of accounts by code hash. Returns json-encoded AccountsList or throw error
  Future<String> getAccountsByCodeHash(
          {required String codeHash,
          required int limit,
          String? continuation}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplGetAccountsByCodeHash(
              that: this,
              codeHash: codeHash,
              limit: limit,
              continuation: continuation);

  /// Get config of transport.
  /// Returns json-encoded BlockchainConfigDef or throw error
  Future<String> getBlockchainConfig({required bool force}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplGetBlockchainConfig(
              that: this, force: force);

  /// Get contract state of address and return json-encoded RawContractState or throw error
  Future<String> getContractState({required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplGetContractState(
              that: this, address: address);

  /// Call get_dst_transaction of nekoton's transport and
  /// return option json-encoded RawTransaction or throw error
  Future<String?> getDstTransaction({required String messageHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplGetDstTransaction(
              that: this, messageHash: messageHash);

  Future<String> getFeeFactors({required bool isMasterchain}) =>
      NekotonBridge.instance.api.crateApiMergedJrpcTransportImplGetFeeFactors(
          that: this, isMasterchain: isMasterchain);

  /// Get full contract state of address and return json-encoded FullContractState or throw error
  Future<String?> getFullContractState({required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplGetFullContractState(
              that: this, address: address);

  /// Get id of network or throw error
  Future<int> getNetworkId() =>
      NekotonBridge.instance.api.crateApiMergedJrpcTransportImplGetNetworkId(
        that: this,
      );

  /// Get transport signature id and return it or throw error
  Future<int?> getSignatureId() =>
      NekotonBridge.instance.api.crateApiMergedJrpcTransportImplGetSignatureId(
        that: this,
      );

  /// Get single transaction by its hash.
  /// Return json-encoded Transaction or throw error
  Future<String?> getTransaction({required String hash}) => NekotonBridge
      .instance.api
      .crateApiMergedJrpcTransportImplGetTransaction(that: this, hash: hash);

  /// Get list of transactions by address.
  /// Return json-encoded TransactionsList or throw error
  Future<String> getTransactions(
          {required String address, String? fromLt, required int count}) =>
      NekotonBridge.instance.api.crateApiMergedJrpcTransportImplGetTransactions(
          that: this, address: address, fromLt: fromLt, count: count);

  factory JrpcTransportImpl(
          {required JrpcConnectionDartWrapper jrpcConnection}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplNew(jrpcConnection: jrpcConnection);

  Future<String> simulateTransactionTree(
          {required String signedMessage,
          required List<int> ignoredComputePhaseCodes,
          required List<int> ignoredActionPhaseCodes}) =>
      NekotonBridge.instance.api
          .crateApiMergedJrpcTransportImplSimulateTransactionTree(
              that: this,
              signedMessage: signedMessage,
              ignoredComputePhaseCodes: ignoredComputePhaseCodes,
              ignoredActionPhaseCodes: ignoredActionPhaseCodes);

  @override
  int get hashCode => innerTransport.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JrpcTransportImpl &&
          runtimeType == other.runtimeType &&
          innerTransport == other.innerTransport;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/keystore/keystore_api.rs
///----------------------------
class KeystoreDartWrapper {
  final ArcKeyStoreApiBoxTrait innerKeystore;

  const KeystoreDartWrapper({
    required this.innerKeystore,
  });

  /// Insert new key in keystore. Returns json-encoded KeystoreEntry or throw error.
  /// input - json-encoded action specified for signer eg EncryptedKeyCreateInput or
  ///   DerivedKeyCreateInput or LedgerKeyCreateInput
  Future<String> addKey({required KeySigner signer, required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperAddKey(
          that: this, signer: signer, input: input);

  /// Method same as add_key but allows add multiple keys at time.
  /// Returns json-encoded list of KeyStoreEntry or throw error.
  /// input - json-encoded list of inputs, same as in add_key method
  Future<String> addKeys({required KeySigner signer, required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperAddKeys(
          that: this, signer: signer, input: input);

  /// Clear KeyStore and remove all entries and all sensitive data.
  Future<String> clearKeystore() =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperClearKeystore(
        that: this,
      );

  /// Decrypt json-encoded EncryptedData in data.
  /// input - json-encoded action for signer eg EncryptedKeyPassword or DerivedKeyPassword or
  ///   LedgerSignInput.
  /// Returns base64-encoded data or throw error.
  Future<String> decrypt(
          {required KeySigner signer,
          required String data,
          required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperDecrypt(
          that: this, signer: signer, data: data, input: input);

  /// Encrypt data with specified algorithm and input specified for signer eg EncryptedKeyPassword
  ///   or DerivedKeyPassword or LedgerSignInput.
  /// data - base64 encoded data that must be encrypted.
  /// algorithm - name of algorithm that should be used for encryption, for example ChaCha20Poly1305
  /// public_keys - list of keys that is used for encryption.
  ///
  /// Returns json-encoded list of EncryptedData or throw error.
  Future<String> encrypt(
          {required KeySigner signer,
          required String data,
          required List<String> publicKeys,
          required String algorithm,
          required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperEncrypt(
          that: this,
          signer: signer,
          data: data,
          publicKeys: publicKeys,
          algorithm: algorithm,
          input: input);

  /// Export key and get its seed phrase and mnemonic type.
  /// THIS METHOD DO NOT WORK for LEDGER.
  /// Returns json-encoded EncryptedKeyExportSeedOutput or DerivedKeyExportOutput or throw error
  Future<String> exportSeed(
          {required KeySigner signer, required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperExportSeed(
          that: this, signer: signer, input: input);

  /// Get list of json-encoded KeyStoreEntry or throw error
  Future<String> getEntries() =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperGetEntries(
        that: this,
      );

  /// Return list of public keys specified for signer or throw error.
  /// input - json-encoded action specified for signer eg EncryptedKeyGetPublicKeys or
  ///   DerivedKeyGetPublicKeys or LedgerKeyGetPublicKeys
  Future<List<String>> getPublicKeys(
          {required KeySigner signer, required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperGetPublicKeys(
          that: this, signer: signer, input: input);

  /// Check if password cached for specified public_key.
  /// duration - timestamp in milliseconds of expiring key.
  /// Returns true/false or throw error.
  Future<bool> isPasswordCached(
          {required String publicKey, required BigInt duration}) =>
      NekotonBridge.instance.api
          .crateApiMergedKeystoreDartWrapperIsPasswordCached(
              that: this, publicKey: publicKey, duration: duration);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create KeyStore or throw error
  static Future<KeystoreDartWrapper> newInstance(
          {required StorageDartWrapper storage,
          required List<KeySigner> signers,
          LedgerConnectionDartWrapper? ledgerConnection}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperNew(
          storage: storage,
          signers: signers,
          ledgerConnection: ledgerConnection);

  /// Try to reload all stored data.
  Future<String> reloadKeystore() => NekotonBridge.instance.api
          .crateApiMergedKeystoreDartWrapperReloadKeystore(
        that: this,
      );

  /// Remove public key from KeyStore and return json-encoded KeyStoreEntry if it was removed.
  Future<String?> removeKey({required String publicKey}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperRemoveKey(
          that: this, publicKey: publicKey);

  /// Remove list of public key from KeyStore and return json-encoded list of KeyStoreEntry's
  /// that were removed or throw error.
  Future<String> removeKeys({required List<String> publicKeys}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperRemoveKeys(
          that: this, publicKeys: publicKeys);

  /// Sign data and return base64-encoded signature or throw error.
  /// input - json-encoded action for signer eg EncryptedKeyPassword or DerivedKeyPassword or
  ///   LedgerSignInput.
  /// signature_id - id of transport
  /// data - base64-encoded data that should be signed.
  Future<String> sign(
          {required KeySigner signer,
          required String data,
          required String input,
          int? signatureId}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperSign(
          that: this,
          signer: signer,
          data: data,
          input: input,
          signatureId: signatureId);

  /// Same method as sign.
  /// data - base64-encoded string.
  /// Return SignedData or throw error.
  Future<SignedData> signData(
          {required KeySigner signer,
          required String data,
          required String input,
          int? signatureId}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperSignData(
          that: this,
          signer: signer,
          data: data,
          input: input,
          signatureId: signatureId);

  /// Same method as sign.
  /// data - base64-encoded string.
  /// Return SignedDataRaw or throw error.
  Future<SignedDataRaw> signDataRaw(
          {required KeySigner signer,
          required String data,
          required String input,
          int? signatureId}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperSignDataRaw(
          that: this,
          signer: signer,
          data: data,
          input: input,
          signatureId: signatureId);

  /// Update key data.
  /// Returns updated json-encoded KeyStoreEntry or throw error.
  /// input - json-encoded action specified for signer eg EncryptedKeyUpdateParams or
  ///   DerivedKeyUpdateParams or LedgerUpdateKeyInput
  Future<String> updateKey(
          {required KeySigner signer, required String input}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperUpdateKey(
          that: this, signer: signer, input: input);

  /// Verify if data is valid with specified signers and connection or not.
  /// Return true/false or throw error.
  static Future<bool> verifyData(
          {required List<KeySigner> signers,
          LedgerConnectionDartWrapper? ledgerConnection,
          required String data}) =>
      NekotonBridge.instance.api.crateApiMergedKeystoreDartWrapperVerifyData(
          signers: signers, ledgerConnection: ledgerConnection, data: data);

  @override
  int get hashCode => innerKeystore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeystoreDartWrapper &&
          runtimeType == other.runtimeType &&
          innerKeystore == other.innerKeystore;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/transport/gql_transport_api.rs
///----------------------------
class LatestBlock {
  final String id;
  final BigInt endLt;
  final int genUtime;

  const LatestBlock({
    required this.id,
    required this.endLt,
    required this.genUtime,
  });

  @override
  int get hashCode => id.hashCode ^ endLt.hashCode ^ genUtime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LatestBlock &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          endLt == other.endLt &&
          genUtime == other.genUtime;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/external/ledger_connection_api.rs
///----------------------------
/// This is a wrapper structure above LedgerConnectionBoxTrait to provide instance in dart side.
class LedgerConnectionDartWrapper {
  final ArcLedgerConnectionBoxTrait innerConnection;

  const LedgerConnectionDartWrapper.raw({
    required this.innerConnection,
  });

  factory LedgerConnectionDartWrapper({required String instanceHash}) =>
      NekotonBridge.instance.api.crateApiMergedLedgerConnectionDartWrapperNew(
          instanceHash: instanceHash);

  @override
  int get hashCode => innerConnection.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LedgerConnectionDartWrapper &&
          runtimeType == other.runtimeType &&
          innerConnection == other.innerConnection;
}

/// Implementation of nekoton's LedgerConnection
class LedgerConnectionImpl {
  final String instanceHash;

  const LedgerConnectionImpl.raw({
    required this.instanceHash,
  });

  factory LedgerConnectionImpl({required String instanceHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedLedgerConnectionImplNew(instanceHash: instanceHash);

  @override
  int get hashCode => instanceHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LedgerConnectionImpl &&
          runtimeType == other.runtimeType &&
          instanceHash == other.instanceHash;
}

@freezed
sealed class MnemonicType with _$MnemonicType {
  const MnemonicType._();

  const factory MnemonicType.legacy() = MnemonicType_Legacy;
  const factory MnemonicType.bip39(
    Bip39MnemonicData field0,
  ) = MnemonicType_Bip39;
}

class MyClass {
  final int val;

  const MyClass({
    required this.val,
  });

  Future<String> myFormat() =>
      NekotonBridge.instance.api.crateApiMergedMyClassMyFormat(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<MyClass> newInstance({required int a}) =>
      NekotonBridge.instance.api.crateApiMergedMyClassNew(a: a);

  @override
  int get hashCode => val.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MyClass && runtimeType == other.runtimeType && val == other.val;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/ton_wallet/ton_wallet_api.rs
///----------------------------
enum PollingMethod {
  /// Manual polling once a minute or by a click.
  /// Used when there are no pending transactions
  manual,

  /// Block-walking for GQL or fast refresh for ADNL.
  /// Used when there are some pending transactions
  reliable,
  ;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/external/proto_connection_api.rs
///----------------------------
/// This is a wrapper structure above ProtoConnectionBoxTrait to provide instance in dart side.
class ProtoConnectionDartWrapper {
  final ArcProtoConnectionBoxTrait innerConnection;

  const ProtoConnectionDartWrapper.raw({
    required this.innerConnection,
  });

  factory ProtoConnectionDartWrapper({required String instanceHash}) =>
      NekotonBridge.instance.api.crateApiMergedProtoConnectionDartWrapperNew(
          instanceHash: instanceHash);

  @override
  int get hashCode => innerConnection.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProtoConnectionDartWrapper &&
          runtimeType == other.runtimeType &&
          innerConnection == other.innerConnection;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/transport/proto_transport_api.rs
///----------------------------
/// Wrapper structure above ProtoTransport that provides interface to communicate with it
/// via TransportBoxTrait.
class ProtoTransportImpl {
  final ArcTransportBoxTrait innerTransport;

  const ProtoTransportImpl.raw({
    required this.innerTransport,
  });

  /// Get list of accounts by code hash. Returns json-encoded AccountsList or throw error
  Future<String> getAccountsByCodeHash(
          {required String codeHash,
          required int limit,
          String? continuation}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetAccountsByCodeHash(
              that: this,
              codeHash: codeHash,
              limit: limit,
              continuation: continuation);

  /// Get config of transport.
  /// Returns json-encoded BlockchainConfigDef or throw error
  Future<String> getBlockchainConfig({required bool force}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetBlockchainConfig(
              that: this, force: force);

  /// Get contract state of address and return json-encoded RawContractState or throw error
  Future<String> getContractState({required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetContractState(
              that: this, address: address);

  /// Call get_dst_transaction of nekoton's transport and
  /// return option json-encoded RawTransaction or throw error
  Future<String?> getDstTransaction({required String messageHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetDstTransaction(
              that: this, messageHash: messageHash);

  Future<String> getFeeFactors({required bool isMasterchain}) =>
      NekotonBridge.instance.api.crateApiMergedProtoTransportImplGetFeeFactors(
          that: this, isMasterchain: isMasterchain);

  /// Get full contract state of address and return json-encoded FullContractState or throw error
  Future<String?> getFullContractState({required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetFullContractState(
              that: this, address: address);

  /// Get id of network or throw error
  Future<int> getNetworkId() =>
      NekotonBridge.instance.api.crateApiMergedProtoTransportImplGetNetworkId(
        that: this,
      );

  /// Get transport signature id and return it or throw error
  Future<int?> getSignatureId() =>
      NekotonBridge.instance.api.crateApiMergedProtoTransportImplGetSignatureId(
        that: this,
      );

  /// Get single transaction by its hash.
  /// Return json-encoded Transaction or throw error
  Future<String?> getTransaction({required String hash}) => NekotonBridge
      .instance.api
      .crateApiMergedProtoTransportImplGetTransaction(that: this, hash: hash);

  /// Get list of transactions by address.
  /// Return json-encoded TransactionsList or throw error
  Future<String> getTransactions(
          {required String address, String? fromLt, required int count}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplGetTransactions(
              that: this, address: address, fromLt: fromLt, count: count);

  factory ProtoTransportImpl(
          {required ProtoConnectionDartWrapper protoConnection}) =>
      NekotonBridge.instance.api.crateApiMergedProtoTransportImplNew(
          protoConnection: protoConnection);

  Future<String> simulateTransactionTree(
          {required String signedMessage,
          required List<int> ignoredComputePhaseCodes,
          required List<int> ignoredActionPhaseCodes}) =>
      NekotonBridge.instance.api
          .crateApiMergedProtoTransportImplSimulateTransactionTree(
              that: this,
              signedMessage: signedMessage,
              ignoredComputePhaseCodes: ignoredComputePhaseCodes,
              ignoredActionPhaseCodes: ignoredActionPhaseCodes);

  @override
  int get hashCode => innerTransport.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProtoTransportImpl &&
          runtimeType == other.runtimeType &&
          innerTransport == other.innerTransport;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/external/storage_api.rs
///----------------------------
/// This is a wrapper structure above StorageBoxTrait to provide instance in dart side.
class StorageDartWrapper {
  final ArcStorageBoxTrait innerStorage;

  const StorageDartWrapper({
    required this.innerStorage,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<StorageDartWrapper> newInstance(
          {required String instanceHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedStorageDartWrapperNew(instanceHash: instanceHash);

  @override
  int get hashCode => innerStorage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StorageDartWrapper &&
          runtimeType == other.runtimeType &&
          innerStorage == other.innerStorage;
}

/// Implementation of nekoton's Storage
class StorageImpl {
  final String instanceHash;

  const StorageImpl({
    required this.instanceHash,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<StorageImpl> newInstance({required String instanceHash}) =>
      NekotonBridge.instance.api
          .crateApiMergedStorageImplNew(instanceHash: instanceHash);

  @override
  int get hashCode => instanceHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StorageImpl &&
          runtimeType == other.runtimeType &&
          instanceHash == other.instanceHash;
}

///----------------------------
/// CONTENT OF src/nekoton_wrapper/core/token_wallet/token_wallet_api.rs
///----------------------------
class TokenWalletDartWrapper {
  final ArcTokenWalletBoxTrait innerWallet;

  const TokenWalletDartWrapper({
    required this.innerWallet,
  });

  /// Get address of wallet.
  Future<String> address() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperAddress(
        that: this,
      );

  /// Get balance of wallet.
  /// Return string representation of rust BigUInt
  Future<String> balance() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperBalance(
        that: this,
      );

  /// Get json-encoded ContractState or throw error.
  Future<String> contractState() => NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperContractState(
        that: this,
      );

  Future<String> estimateMinAttachedAmount(
          {required String destination,
          required String amount,
          required bool notifyReceiver,
          String? payload}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperEstimateMinAttachedAmount(
              that: this,
              destination: destination,
              amount: amount,
              notifyReceiver: notifyReceiver,
              payload: payload);

  /// Get details about root contract by address of TokenWallet
  /// Return json-encoded RootTokenContractDetails
  /// or throw error.
  static Future<String> getTokenRootDetails(
          {required ArcTransportBoxTrait transport,
          required String tokenRootAddress}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperGetTokenRootDetails(
              transport: transport, tokenRootAddress: tokenRootAddress);

  /// Get details about root contract by address of TokenWallet
  /// Return json-encoded list with 2 positions:
  /// 0: Address of root contract
  /// 1: RootTokenContractDetails of root contract
  /// or throw error.
  static Future<String> getTokenRootDetailsFromTokenWallet(
          {required ArcTransportBoxTrait transport,
          required String tokenWalletAddress}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperGetTokenRootDetailsFromTokenWallet(
              transport: transport, tokenWalletAddress: tokenWalletAddress);

  /// Get details about token wallet by address of wallet
  /// address - address of wallet
  /// Return json-encoded list with 2 positions:
  /// 0: TokenWalletDetails
  /// 1: RootTokenContractDetails
  /// or throw error
  static Future<String> getTokenWalletDetails(
          {required ArcTransportBoxTrait transport, required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperGetTokenWalletDetails(
              transport: transport, address: address);

  /// Handle block of blockchain.
  /// block - base64-encoded Block.
  /// Return true or throw error.
  Future<bool> handleBlock({required String block}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperHandleBlock(
              that: this, block: block);

  /// Get address of owner of wallet.
  Future<String> owner() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperOwner(
        that: this,
      );

  /// Preload transactions of wallet.
  /// from_lt - offset for loading data, string representation of u64
  /// Returns true or throw error.
  Future<bool> preloadTransactions({required String fromLt}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperPreloadTransactions(
              that: this, fromLt: fromLt);

  /// Prepare transferring tokens from this wallet to other.
  /// destination - address of account that should receive token
  /// amount - amount of tokens that should be transferred
  /// notify_receiver - if receiver should be notifier by blockchain
  /// payload - payload of transfer aka comment
  /// attached_amount - string representation of rust u64, default 400000000. How many native tokens
  ///   should be attached to transfer.
  /// Return json-encoded InternalMessage or throw error.
  Future<String> prepareTransfer(
          {required String destination,
          required String amount,
          required bool notifyReceiver,
          String? attachedAmount,
          String? payload}) =>
      NekotonBridge.instance.api
          .crateApiMergedTokenWalletDartWrapperPrepareTransfer(
              that: this,
              destination: destination,
              amount: amount,
              notifyReceiver: notifyReceiver,
              attachedAmount: attachedAmount,
              payload: payload);

  /// Refresh wallet and update its data.
  /// Returns true or throw error.
  Future<bool> refresh() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperRefresh(
        that: this,
      );

  /// Create TokenWallet by subscribing to its instance.
  /// owner - address of account that is owner of wallet
  /// root_token_contract - address of contract in blockchain
  static Future<TokenWalletDartWrapper> subscribe(
          {required String instanceHash,
          required String owner,
          required String rootTokenContract,
          required ArcTransportBoxTrait transport,
          required bool preloadTransactions}) =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperSubscribe(
          instanceHash: instanceHash,
          owner: owner,
          rootTokenContract: rootTokenContract,
          transport: transport,
          preloadTransactions: preloadTransactions);

  /// Get symbol of contract of wallet.
  /// Return json-encoded Symbol or throw error
  Future<String> symbol() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperSymbol(
        that: this,
      );

  /// Get json-encoded TokenWalletVersion or throw error.
  Future<String> version() =>
      NekotonBridge.instance.api.crateApiMergedTokenWalletDartWrapperVersion(
        that: this,
      );

  @override
  int get hashCode => innerWallet.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenWalletDartWrapper &&
          runtimeType == other.runtimeType &&
          innerWallet == other.innerWallet;
}

class TonWalletDartWrapper {
  final ArcTonWalletBoxTrait innerWallet;

  const TonWalletDartWrapper({
    required this.innerWallet,
  });

  /// Get address of wallet.
  Future<String> address() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperAddress(
        that: this,
      );

  /// Get json-encoded ContractState or throw error.
  Future<String> contractState() => NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperContractState(
        that: this,
      );

  /// Get optional list of custodians.
  /// Returns list of public keys.
  Future<List<String>?> custodians() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperCustodians(
        that: this,
      );

  /// Get json-encoded TonWalletDetails or throw error.
  Future<String> details() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperDetails(
        that: this,
      );

  /// Calculate fees for transaction.
  /// signed_message - json-encoded SignedMessage.
  /// execution_options - json-encoded ExecutionOptions.
  /// Returns fees as string representation of u128 or throw error.
  Future<String> estimateFees(
          {required String signedMessage, String? executionOptions}) =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperEstimateFees(
          that: this,
          signedMessage: signedMessage,
          executionOptions: executionOptions);

  /// Find list of wallets of public_key and return them.
  /// wallet_types - json-encoded list of WalletType.
  /// public_key - key of account where wallets must be found.
  /// Return json-encoded list of ExistingWalletInfo or throw error.
  static Future<String> findExistingWallets(
          {required ArcTransportBoxTrait transport,
          required String publicKey,
          required int workchainId,
          required String walletTypes}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperFindExistingWallets(
              transport: transport,
              publicKey: publicKey,
              workchainId: workchainId,
              walletTypes: walletTypes);

  /// Get list of custodians of account by address.
  /// Return list of public keys or throw error.
  static Future<List<String>> getCustodians(
          {required ArcTransportBoxTrait transport, required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperGetCustodians(
              transport: transport, address: address);

  /// Get information of account by its address.
  /// Return json-encoded ExistingWalletInfo or throw error.
  static Future<String> getExistingWalletInfo(
          {required ArcTransportBoxTrait transport, required String address}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperGetExistingWalletInfo(
              transport: transport, address: address);

  /// Handle block of blockchain.
  /// block - base64-encoded Block.
  /// Return true or throw error.
  Future<bool> handleBlock({required String block}) => NekotonBridge
      .instance.api
      .crateApiMergedTonWalletDartWrapperHandleBlock(that: this, block: block);

  Future<String> makeStateInit() => NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperMakeStateInit(
        that: this,
      );

  /// Get list of json-encoded PendingTransaction or throw error.
  Future<String> pendingTransactions() => NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPendingTransactions(
        that: this,
      );

  /// Get PollingMethod of wallet or throw error.
  Future<PollingMethod> pollingMethod() => NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPollingMethod(
        that: this,
      );

  /// Preload transactions of wallet.
  /// from_lt - offset for loading data, string representation of u64
  /// Returns true or throw error.
  Future<bool> preloadTransactions({required String fromLt}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPreloadTransactions(
              that: this, fromLt: fromLt);

  /// Prepare transaction for confirmation.
  /// contract_state - json-encoded RawContractState
  /// public_key - key of account that had initiated transfer
  /// transaction_id - id of transaction.
  /// expiration - json-encoded Expiration
  /// Returns UnsignedMessage or throw error.
  Future<UnsignedMessageImpl> prepareConfirmTransaction(
          {required String contractState,
          required String publicKey,
          required String transactionId,
          required String expiration}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPrepareConfirmTransaction(
              that: this,
              contractState: contractState,
              publicKey: publicKey,
              transactionId: transactionId,
              expiration: expiration);

  /// Prepare TonWallet for deploy action.
  /// expiration - json-encoded Expiration.
  /// Returns UnsignedMessage or throw error.
  Future<UnsignedMessageImpl> prepareDeploy({required String expiration}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPrepareDeploy(
              that: this, expiration: expiration);

  /// Prepare TonWallet for deploy actions if wallet is multisig.
  /// expiration - json-encoded Expiration.
  /// custodians - list of public keys of custodians.
  /// req_confirms - count of required confirmations from 1 to custodians count
  /// Returns UnsignedMessage or throw error.
  Future<UnsignedMessageImpl> prepareDeployWithMultipleOwners(
          {required String expiration,
          required List<String> custodians,
          required int reqConfirms,
          int? expirationTime}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPrepareDeployWithMultipleOwners(
              that: this,
              expiration: expiration,
              custodians: custodians,
              reqConfirms: reqConfirms,
              expirationTime: expirationTime);

  /// Prepare transferring tokens from this wallet to other.
  /// contract_state - json-encoded RawContractState
  /// public_key - key of account that had initiated transfer
  /// expiration - json-encoded Expiration
  /// params - json-encoded list of TonWalletTransferParams
  /// Returns UnsignedMessage or throw error.
  Future<UnsignedMessageImpl> prepareTransfer(
          {required String contractState,
          required String publicKey,
          required String expiration,
          required String params}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperPrepareTransfer(
              that: this,
              contractState: contractState,
              publicKey: publicKey,
              expiration: expiration,
              params: params);

  /// Get public key of wallet.
  Future<String> publicKey() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperPublicKey(
        that: this,
      );

  /// Refresh wallet and update its data.
  /// Returns true or throw error.
  Future<bool> refresh() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperRefresh(
        that: this,
      );

  /// Send message to blockchain and receive transaction of send.
  /// signed_message - json-encoded SignedMessage.
  /// Returns json-encoded PendingTransaction or throw error.
  Future<String> send({required String signedMessage}) =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperSend(
          that: this, signedMessage: signedMessage);

  /// Create TonWallet by subscribing to its instance by public_key.
  /// wallet_type - is json-encoded WalletType.
  /// public_key - is string representation of key
  static Future<TonWalletDartWrapper> subscribe(
          {required String instanceHash,
          required int workchainId,
          required String publicKey,
          required String walletType,
          required ArcTransportBoxTrait transport}) =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperSubscribe(
          instanceHash: instanceHash,
          workchainId: workchainId,
          publicKey: publicKey,
          walletType: walletType,
          transport: transport);

  /// Create TonWallet by subscribing to its instance by address of wallet.
  static Future<TonWalletDartWrapper> subscribeByAddress(
          {required String instanceHash,
          required String address,
          required ArcTransportBoxTrait transport}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperSubscribeByAddress(
              instanceHash: instanceHash,
              address: address,
              transport: transport);

  /// Create TonWallet by subscribing to its instance by existed instance.
  /// existing_wallet - json-encoded ExistingWalletInfo.
  static Future<TonWalletDartWrapper> subscribeByExisting(
          {required String instanceHash,
          required String existingWallet,
          required ArcTransportBoxTrait transport}) =>
      NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperSubscribeByExisting(
              instanceHash: instanceHash,
              existingWallet: existingWallet,
              transport: transport);

  /// Get json-encoded list of MultisigPendingTransaction or throw error.
  Future<String> unconfirmedTransactions() => NekotonBridge.instance.api
          .crateApiMergedTonWalletDartWrapperUnconfirmedTransactions(
        that: this,
      );

  /// Get json-encoded WalletType or throw error.
  Future<String> walletType() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperWalletType(
        that: this,
      );

  /// Get workchain of wallet.
  Future<int> workchain() =>
      NekotonBridge.instance.api.crateApiMergedTonWalletDartWrapperWorkchain(
        that: this,
      );

  @override
  int get hashCode => innerWallet.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TonWalletDartWrapper &&
          runtimeType == other.runtimeType &&
          innerWallet == other.innerWallet;
}

/// This struct creates only in rust side and describes UnsignedMessage
class UnsignedMessageImpl {
  final ArcUnsignedMessageBoxTrait innerMessage;

  const UnsignedMessageImpl({
    required this.innerMessage,
  });

  /// Return current expiration timestamp of UnsignedMessage
  /// Returns secondsSinceEpoch
  Future<int> expireAt() =>
      NekotonBridge.instance.api.crateApiMergedUnsignedMessageImplExpireAt(
        that: this,
      );

  /// Returns base64 encoded hash string of UnsignedMessage
  Future<String> hash() =>
      NekotonBridge.instance.api.crateApiMergedUnsignedMessageImplHash(
        that: this,
      );

  Future<void> refreshTimeout() => NekotonBridge.instance.api
          .crateApiMergedUnsignedMessageImplRefreshTimeout(
        that: this,
      );

  /// Sign message with signature and return json-encoded SignedMessage.
  /// signature receives from KeyStore.sign where data is UnsignedMessage.hash
  Future<String> sign({required String signature}) => NekotonBridge.instance.api
      .crateApiMergedUnsignedMessageImplSign(that: this, signature: signature);

  /// Sign message with fake signature and return json-encoded SignedMessage or throws error
  Future<String> signFake() =>
      NekotonBridge.instance.api.crateApiMergedUnsignedMessageImplSignFake(
        that: this,
      );

  @override
  int get hashCode => innerMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedMessageImpl &&
          runtimeType == other.runtimeType &&
          innerMessage == other.innerMessage;
}
